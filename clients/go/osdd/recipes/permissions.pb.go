// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.10
// 	protoc        v5.29.3
// source: osdd/recipes/permissions.proto

package recipes

import (
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type OperationPermission struct {
	state           protoimpl.MessageState     `protogen:"opaque.v1"`
	xxx_hidden_Type isOperationPermission_Type `protobuf_oneof:"type"`
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *OperationPermission) Reset() {
	*x = OperationPermission{}
	mi := &file_osdd_recipes_permissions_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *OperationPermission) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*OperationPermission) ProtoMessage() {}

func (x *OperationPermission) ProtoReflect() protoreflect.Message {
	mi := &file_osdd_recipes_permissions_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *OperationPermission) GetBash() string {
	if x != nil {
		if x, ok := x.xxx_hidden_Type.(*operationPermission_Bash); ok {
			return x.Bash
		}
	}
	return ""
}

func (x *OperationPermission) GetRead() string {
	if x != nil {
		if x, ok := x.xxx_hidden_Type.(*operationPermission_Read); ok {
			return x.Read
		}
	}
	return ""
}

func (x *OperationPermission) GetWrite() string {
	if x != nil {
		if x, ok := x.xxx_hidden_Type.(*operationPermission_Write); ok {
			return x.Write
		}
	}
	return ""
}

func (x *OperationPermission) SetBash(v string) {
	x.xxx_hidden_Type = &operationPermission_Bash{v}
}

func (x *OperationPermission) SetRead(v string) {
	x.xxx_hidden_Type = &operationPermission_Read{v}
}

func (x *OperationPermission) SetWrite(v string) {
	x.xxx_hidden_Type = &operationPermission_Write{v}
}

func (x *OperationPermission) HasType() bool {
	if x == nil {
		return false
	}
	return x.xxx_hidden_Type != nil
}

func (x *OperationPermission) HasBash() bool {
	if x == nil {
		return false
	}
	_, ok := x.xxx_hidden_Type.(*operationPermission_Bash)
	return ok
}

func (x *OperationPermission) HasRead() bool {
	if x == nil {
		return false
	}
	_, ok := x.xxx_hidden_Type.(*operationPermission_Read)
	return ok
}

func (x *OperationPermission) HasWrite() bool {
	if x == nil {
		return false
	}
	_, ok := x.xxx_hidden_Type.(*operationPermission_Write)
	return ok
}

func (x *OperationPermission) ClearType() {
	x.xxx_hidden_Type = nil
}

func (x *OperationPermission) ClearBash() {
	if _, ok := x.xxx_hidden_Type.(*operationPermission_Bash); ok {
		x.xxx_hidden_Type = nil
	}
}

func (x *OperationPermission) ClearRead() {
	if _, ok := x.xxx_hidden_Type.(*operationPermission_Read); ok {
		x.xxx_hidden_Type = nil
	}
}

func (x *OperationPermission) ClearWrite() {
	if _, ok := x.xxx_hidden_Type.(*operationPermission_Write); ok {
		x.xxx_hidden_Type = nil
	}
}

const OperationPermission_Type_not_set_case case_OperationPermission_Type = 0
const OperationPermission_Bash_case case_OperationPermission_Type = 100
const OperationPermission_Read_case case_OperationPermission_Type = 101
const OperationPermission_Write_case case_OperationPermission_Type = 102

func (x *OperationPermission) WhichType() case_OperationPermission_Type {
	if x == nil {
		return OperationPermission_Type_not_set_case
	}
	switch x.xxx_hidden_Type.(type) {
	case *operationPermission_Bash:
		return OperationPermission_Bash_case
	case *operationPermission_Read:
		return OperationPermission_Read_case
	case *operationPermission_Write:
		return OperationPermission_Write_case
	default:
		return OperationPermission_Type_not_set_case
	}
}

type OperationPermission_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

	// Fields of oneof xxx_hidden_Type:
	Bash  *string
	Read  *string
	Write *string
	// -- end of xxx_hidden_Type
}

func (b0 OperationPermission_builder) Build() *OperationPermission {
	m0 := &OperationPermission{}
	b, x := &b0, m0
	_, _ = b, x
	if b.Bash != nil {
		x.xxx_hidden_Type = &operationPermission_Bash{*b.Bash}
	}
	if b.Read != nil {
		x.xxx_hidden_Type = &operationPermission_Read{*b.Read}
	}
	if b.Write != nil {
		x.xxx_hidden_Type = &operationPermission_Write{*b.Write}
	}
	return m0
}

type case_OperationPermission_Type protoreflect.FieldNumber

func (x case_OperationPermission_Type) String() string {
	md := file_osdd_recipes_permissions_proto_msgTypes[0].Descriptor()
	if x == 0 {
		return "not set"
	}
	return protoimpl.X.MessageFieldStringOf(md, protoreflect.FieldNumber(x))
}

type isOperationPermission_Type interface {
	isOperationPermission_Type()
}

type operationPermission_Bash struct {
	Bash string `protobuf:"bytes,100,opt,name=bash,proto3,oneof"`
}

type operationPermission_Read struct {
	Read string `protobuf:"bytes,101,opt,name=read,proto3,oneof"`
}

type operationPermission_Write struct {
	Write string `protobuf:"bytes,102,opt,name=write,proto3,oneof"`
}

func (*operationPermission_Bash) isOperationPermission_Type() {}

func (*operationPermission_Read) isOperationPermission_Type() {}

func (*operationPermission_Write) isOperationPermission_Type() {}

type Permissions struct {
	state            protoimpl.MessageState  `protogen:"opaque.v1"`
	xxx_hidden_Allow *[]*OperationPermission `protobuf:"bytes,1,rep,name=allow,proto3"`
	xxx_hidden_Deny  *[]*OperationPermission `protobuf:"bytes,2,rep,name=deny,proto3"`
	unknownFields    protoimpl.UnknownFields
	sizeCache        protoimpl.SizeCache
}

func (x *Permissions) Reset() {
	*x = Permissions{}
	mi := &file_osdd_recipes_permissions_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Permissions) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Permissions) ProtoMessage() {}

func (x *Permissions) ProtoReflect() protoreflect.Message {
	mi := &file_osdd_recipes_permissions_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *Permissions) GetAllow() []*OperationPermission {
	if x != nil {
		if x.xxx_hidden_Allow != nil {
			return *x.xxx_hidden_Allow
		}
	}
	return nil
}

func (x *Permissions) GetDeny() []*OperationPermission {
	if x != nil {
		if x.xxx_hidden_Deny != nil {
			return *x.xxx_hidden_Deny
		}
	}
	return nil
}

func (x *Permissions) SetAllow(v []*OperationPermission) {
	x.xxx_hidden_Allow = &v
}

func (x *Permissions) SetDeny(v []*OperationPermission) {
	x.xxx_hidden_Deny = &v
}

type Permissions_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

	Allow []*OperationPermission
	Deny  []*OperationPermission
}

func (b0 Permissions_builder) Build() *Permissions {
	m0 := &Permissions{}
	b, x := &b0, m0
	_, _ = b, x
	x.xxx_hidden_Allow = &b.Allow
	x.xxx_hidden_Deny = &b.Deny
	return m0
}

var File_osdd_recipes_permissions_proto protoreflect.FileDescriptor

const file_osdd_recipes_permissions_proto_rawDesc = "" +
	"\n" +
	"\x1eosdd/recipes/permissions.proto\x12\x18osdd.recipes.permissions\"a\n" +
	"\x13OperationPermission\x12\x14\n" +
	"\x04bash\x18d \x01(\tH\x00R\x04bash\x12\x14\n" +
	"\x04read\x18e \x01(\tH\x00R\x04read\x12\x16\n" +
	"\x05write\x18f \x01(\tH\x00R\x05writeB\x06\n" +
	"\x04type\"\x95\x01\n" +
	"\vPermissions\x12C\n" +
	"\x05allow\x18\x01 \x03(\v2-.osdd.recipes.permissions.OperationPermissionR\x05allow\x12A\n" +
	"\x04deny\x18\x02 \x03(\v2-.osdd.recipes.permissions.OperationPermissionR\x04denyB5Z3github.com/opensdd/osdd-api/clients/go/osdd/recipesb\x06proto3"

var file_osdd_recipes_permissions_proto_msgTypes = make([]protoimpl.MessageInfo, 2)
var file_osdd_recipes_permissions_proto_goTypes = []any{
	(*OperationPermission)(nil), // 0: osdd.recipes.permissions.OperationPermission
	(*Permissions)(nil),         // 1: osdd.recipes.permissions.Permissions
}
var file_osdd_recipes_permissions_proto_depIdxs = []int32{
	0, // 0: osdd.recipes.permissions.Permissions.allow:type_name -> osdd.recipes.permissions.OperationPermission
	0, // 1: osdd.recipes.permissions.Permissions.deny:type_name -> osdd.recipes.permissions.OperationPermission
	2, // [2:2] is the sub-list for method output_type
	2, // [2:2] is the sub-list for method input_type
	2, // [2:2] is the sub-list for extension type_name
	2, // [2:2] is the sub-list for extension extendee
	0, // [0:2] is the sub-list for field type_name
}

func init() { file_osdd_recipes_permissions_proto_init() }
func file_osdd_recipes_permissions_proto_init() {
	if File_osdd_recipes_permissions_proto != nil {
		return
	}
	file_osdd_recipes_permissions_proto_msgTypes[0].OneofWrappers = []any{
		(*operationPermission_Bash)(nil),
		(*operationPermission_Read)(nil),
		(*operationPermission_Write)(nil),
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_osdd_recipes_permissions_proto_rawDesc), len(file_osdd_recipes_permissions_proto_rawDesc)),
			NumEnums:      0,
			NumMessages:   2,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_osdd_recipes_permissions_proto_goTypes,
		DependencyIndexes: file_osdd_recipes_permissions_proto_depIdxs,
		MessageInfos:      file_osdd_recipes_permissions_proto_msgTypes,
	}.Build()
	File_osdd_recipes_permissions_proto = out.File
	file_osdd_recipes_permissions_proto_goTypes = nil
	file_osdd_recipes_permissions_proto_depIdxs = nil
}
