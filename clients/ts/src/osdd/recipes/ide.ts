// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.8.1
//   protoc               v5.29.3
// source: osdd/recipes/ide.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { GitReference } from "../common";
import { Permissions } from "./permissions";

export const protobufPackage = "osdd.recipes.ide";

export interface Ide {
  commands?: Commands | undefined;
  mcp?: Mcp | undefined;
  permissions?: Permissions | undefined;
}

export interface Mcp {
  servers: { [key: string]: McpServer };
}

export interface Mcp_ServersEntry {
  key: string;
  value: McpServer | undefined;
}

export interface McpServer {
  type?: { $case: "http"; value: HttpMcpServer } | { $case: "stdio"; value: StdioMcpServer } | undefined;
}

export interface HttpMcpServer {
  url: string;
}

export interface StdioMcpServer {
  command: string;
}

export interface Commands {
  entries: Command[];
}

export interface Command {
  name: string;
  from: CommandFrom | undefined;
}

export interface CommandFrom {
  type?:
    | { $case: "github"; value: GitReference }
    | { $case: "cmd"; value: string }
    | { $case: "text"; value: string }
    | undefined;
}

function createBaseIde(): Ide {
  return { commands: undefined, mcp: undefined, permissions: undefined };
}

export const Ide: MessageFns<Ide> = {
  encode(message: Ide, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.commands !== undefined) {
      Commands.encode(message.commands, writer.uint32(10).fork()).join();
    }
    if (message.mcp !== undefined) {
      Mcp.encode(message.mcp, writer.uint32(18).fork()).join();
    }
    if (message.permissions !== undefined) {
      Permissions.encode(message.permissions, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Ide {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIde();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.commands = Commands.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.mcp = Mcp.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.permissions = Permissions.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Ide {
    return {
      commands: isSet(object.commands) ? Commands.fromJSON(object.commands) : undefined,
      mcp: isSet(object.mcp) ? Mcp.fromJSON(object.mcp) : undefined,
      permissions: isSet(object.permissions) ? Permissions.fromJSON(object.permissions) : undefined,
    };
  },

  toJSON(message: Ide): unknown {
    const obj: any = {};
    if (message.commands !== undefined) {
      obj.commands = Commands.toJSON(message.commands);
    }
    if (message.mcp !== undefined) {
      obj.mcp = Mcp.toJSON(message.mcp);
    }
    if (message.permissions !== undefined) {
      obj.permissions = Permissions.toJSON(message.permissions);
    }
    return obj;
  },

  create(base?: DeepPartial<Ide>): Ide {
    return Ide.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Ide>): Ide {
    const message = createBaseIde();
    message.commands = (object.commands !== undefined && object.commands !== null)
      ? Commands.fromPartial(object.commands)
      : undefined;
    message.mcp = (object.mcp !== undefined && object.mcp !== null) ? Mcp.fromPartial(object.mcp) : undefined;
    message.permissions = (object.permissions !== undefined && object.permissions !== null)
      ? Permissions.fromPartial(object.permissions)
      : undefined;
    return message;
  },
};

function createBaseMcp(): Mcp {
  return { servers: {} };
}

export const Mcp: MessageFns<Mcp> = {
  encode(message: Mcp, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    Object.entries(message.servers).forEach(([key, value]) => {
      Mcp_ServersEntry.encode({ key: key as any, value }, writer.uint32(10).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Mcp {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMcp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          const entry1 = Mcp_ServersEntry.decode(reader, reader.uint32());
          if (entry1.value !== undefined) {
            message.servers[entry1.key] = entry1.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Mcp {
    return {
      servers: isObject(object.servers)
        ? Object.entries(object.servers).reduce<{ [key: string]: McpServer }>((acc, [key, value]) => {
          acc[key] = McpServer.fromJSON(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: Mcp): unknown {
    const obj: any = {};
    if (message.servers) {
      const entries = Object.entries(message.servers);
      if (entries.length > 0) {
        obj.servers = {};
        entries.forEach(([k, v]) => {
          obj.servers[k] = McpServer.toJSON(v);
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<Mcp>): Mcp {
    return Mcp.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Mcp>): Mcp {
    const message = createBaseMcp();
    message.servers = Object.entries(object.servers ?? {}).reduce<{ [key: string]: McpServer }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = McpServer.fromPartial(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseMcp_ServersEntry(): Mcp_ServersEntry {
  return { key: "", value: undefined };
}

export const Mcp_ServersEntry: MessageFns<Mcp_ServersEntry> = {
  encode(message: Mcp_ServersEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      McpServer.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Mcp_ServersEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMcp_ServersEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = McpServer.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Mcp_ServersEntry {
    return {
      key: isSet(object.key) ? gt.String(object.key) : "",
      value: isSet(object.value) ? McpServer.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: Mcp_ServersEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = McpServer.toJSON(message.value);
    }
    return obj;
  },

  create(base?: DeepPartial<Mcp_ServersEntry>): Mcp_ServersEntry {
    return Mcp_ServersEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Mcp_ServersEntry>): Mcp_ServersEntry {
    const message = createBaseMcp_ServersEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? McpServer.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseMcpServer(): McpServer {
  return { type: undefined };
}

export const McpServer: MessageFns<McpServer> = {
  encode(message: McpServer, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    switch (message.type?.$case) {
      case "http":
        HttpMcpServer.encode(message.type.value, writer.uint32(802).fork()).join();
        break;
      case "stdio":
        StdioMcpServer.encode(message.type.value, writer.uint32(810).fork()).join();
        break;
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): McpServer {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMcpServer();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 100: {
          if (tag !== 802) {
            break;
          }

          message.type = { $case: "http", value: HttpMcpServer.decode(reader, reader.uint32()) };
          continue;
        }
        case 101: {
          if (tag !== 810) {
            break;
          }

          message.type = { $case: "stdio", value: StdioMcpServer.decode(reader, reader.uint32()) };
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): McpServer {
    return {
      type: isSet(object.http)
        ? { $case: "http", value: HttpMcpServer.fromJSON(object.http) }
        : isSet(object.stdio)
        ? { $case: "stdio", value: StdioMcpServer.fromJSON(object.stdio) }
        : undefined,
    };
  },

  toJSON(message: McpServer): unknown {
    const obj: any = {};
    if (message.type?.$case === "http") {
      obj.http = HttpMcpServer.toJSON(message.type.value);
    } else if (message.type?.$case === "stdio") {
      obj.stdio = StdioMcpServer.toJSON(message.type.value);
    }
    return obj;
  },

  create(base?: DeepPartial<McpServer>): McpServer {
    return McpServer.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<McpServer>): McpServer {
    const message = createBaseMcpServer();
    switch (object.type?.$case) {
      case "http": {
        if (object.type?.value !== undefined && object.type?.value !== null) {
          message.type = { $case: "http", value: HttpMcpServer.fromPartial(object.type.value) };
        }
        break;
      }
      case "stdio": {
        if (object.type?.value !== undefined && object.type?.value !== null) {
          message.type = { $case: "stdio", value: StdioMcpServer.fromPartial(object.type.value) };
        }
        break;
      }
    }
    return message;
  },
};

function createBaseHttpMcpServer(): HttpMcpServer {
  return { url: "" };
}

export const HttpMcpServer: MessageFns<HttpMcpServer> = {
  encode(message: HttpMcpServer, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.url !== "") {
      writer.uint32(10).string(message.url);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HttpMcpServer {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHttpMcpServer();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.url = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HttpMcpServer {
    return { url: isSet(object.url) ? gt.String(object.url) : "" };
  },

  toJSON(message: HttpMcpServer): unknown {
    const obj: any = {};
    if (message.url !== "") {
      obj.url = message.url;
    }
    return obj;
  },

  create(base?: DeepPartial<HttpMcpServer>): HttpMcpServer {
    return HttpMcpServer.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<HttpMcpServer>): HttpMcpServer {
    const message = createBaseHttpMcpServer();
    message.url = object.url ?? "";
    return message;
  },
};

function createBaseStdioMcpServer(): StdioMcpServer {
  return { command: "" };
}

export const StdioMcpServer: MessageFns<StdioMcpServer> = {
  encode(message: StdioMcpServer, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.command !== "") {
      writer.uint32(10).string(message.command);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StdioMcpServer {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStdioMcpServer();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.command = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StdioMcpServer {
    return { command: isSet(object.command) ? gt.String(object.command) : "" };
  },

  toJSON(message: StdioMcpServer): unknown {
    const obj: any = {};
    if (message.command !== "") {
      obj.command = message.command;
    }
    return obj;
  },

  create(base?: DeepPartial<StdioMcpServer>): StdioMcpServer {
    return StdioMcpServer.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StdioMcpServer>): StdioMcpServer {
    const message = createBaseStdioMcpServer();
    message.command = object.command ?? "";
    return message;
  },
};

function createBaseCommands(): Commands {
  return { entries: [] };
}

export const Commands: MessageFns<Commands> = {
  encode(message: Commands, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.entries) {
      Command.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Commands {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCommands();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.entries.push(Command.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Commands {
    return { entries: gt.Array.isArray(object?.entries) ? object.entries.map((e: any) => Command.fromJSON(e)) : [] };
  },

  toJSON(message: Commands): unknown {
    const obj: any = {};
    if (message.entries?.length) {
      obj.entries = message.entries.map((e) => Command.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<Commands>): Commands {
    return Commands.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Commands>): Commands {
    const message = createBaseCommands();
    message.entries = object.entries?.map((e) => Command.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCommand(): Command {
  return { name: "", from: undefined };
}

export const Command: MessageFns<Command> = {
  encode(message: Command, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.from !== undefined) {
      CommandFrom.encode(message.from, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Command {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCommand();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.from = CommandFrom.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Command {
    return {
      name: isSet(object.name) ? gt.String(object.name) : "",
      from: isSet(object.from) ? CommandFrom.fromJSON(object.from) : undefined,
    };
  },

  toJSON(message: Command): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.from !== undefined) {
      obj.from = CommandFrom.toJSON(message.from);
    }
    return obj;
  },

  create(base?: DeepPartial<Command>): Command {
    return Command.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Command>): Command {
    const message = createBaseCommand();
    message.name = object.name ?? "";
    message.from = (object.from !== undefined && object.from !== null)
      ? CommandFrom.fromPartial(object.from)
      : undefined;
    return message;
  },
};

function createBaseCommandFrom(): CommandFrom {
  return { type: undefined };
}

export const CommandFrom: MessageFns<CommandFrom> = {
  encode(message: CommandFrom, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    switch (message.type?.$case) {
      case "github":
        GitReference.encode(message.type.value, writer.uint32(802).fork()).join();
        break;
      case "cmd":
        writer.uint32(810).string(message.type.value);
        break;
      case "text":
        writer.uint32(818).string(message.type.value);
        break;
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CommandFrom {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCommandFrom();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 100: {
          if (tag !== 802) {
            break;
          }

          message.type = { $case: "github", value: GitReference.decode(reader, reader.uint32()) };
          continue;
        }
        case 101: {
          if (tag !== 810) {
            break;
          }

          message.type = { $case: "cmd", value: reader.string() };
          continue;
        }
        case 102: {
          if (tag !== 818) {
            break;
          }

          message.type = { $case: "text", value: reader.string() };
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CommandFrom {
    return {
      type: isSet(object.github)
        ? { $case: "github", value: GitReference.fromJSON(object.github) }
        : isSet(object.cmd)
        ? { $case: "cmd", value: gt.String(object.cmd) }
        : isSet(object.text)
        ? { $case: "text", value: gt.String(object.text) }
        : undefined,
    };
  },

  toJSON(message: CommandFrom): unknown {
    const obj: any = {};
    if (message.type?.$case === "github") {
      obj.github = GitReference.toJSON(message.type.value);
    } else if (message.type?.$case === "cmd") {
      obj.cmd = message.type.value;
    } else if (message.type?.$case === "text") {
      obj.text = message.type.value;
    }
    return obj;
  },

  create(base?: DeepPartial<CommandFrom>): CommandFrom {
    return CommandFrom.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CommandFrom>): CommandFrom {
    const message = createBaseCommandFrom();
    switch (object.type?.$case) {
      case "github": {
        if (object.type?.value !== undefined && object.type?.value !== null) {
          message.type = { $case: "github", value: GitReference.fromPartial(object.type.value) };
        }
        break;
      }
      case "cmd": {
        if (object.type?.value !== undefined && object.type?.value !== null) {
          message.type = { $case: "cmd", value: object.type.value };
        }
        break;
      }
      case "text": {
        if (object.type?.value !== undefined && object.type?.value !== null) {
          message.type = { $case: "text", value: object.type.value };
        }
        break;
      }
    }
    return message;
  },
};

declare const self: any | undefined;
declare const window: any | undefined;
declare const global: any | undefined;
const gt: any = (() => {
  if (typeof globalThis !== "undefined") {
    return globalThis;
  }
  if (typeof self !== "undefined") {
    return self;
  }
  if (typeof window !== "undefined") {
    return window;
  }
  if (typeof global !== "undefined") {
    return global;
  }
  throw "Unable to locate global object";
})();

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends { $case: string; value: unknown } ? { $case: T["$case"]; value?: DeepPartial<T["value"]> }
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
